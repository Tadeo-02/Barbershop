const fs = require("fs");
const forge = require("node-forge");

function validateCertificates() {
  console.log("üîç Validating ARCA certificates and keys...\n");

  const certPath = "./src/API/ARCA/CertificadoBarbershopAutorizado.pem";
  const keyPath = "./src/API/ARCA/ARCAKey.key";

  try {
    // Check if files exist
    console.log("üìÅ Checking file existence...");
    if (!fs.existsSync(certPath)) {
      console.error(`‚ùå Certificate file not found: ${certPath}`);
      return false;
    }
    if (!fs.existsSync(keyPath)) {
      console.error(`‚ùå Private key file not found: ${keyPath}`);
      return false;
    }
    console.log("‚úÖ Both files exist");

    // Read files
    console.log("\nüìñ Reading certificate and key files...");
    const certPem = fs.readFileSync(certPath, "utf8");
    const keyPem = fs.readFileSync(keyPath, "utf8");

    // Validate certificate format
    console.log("üîç Validating certificate format...");
    if (!certPem.includes("-----BEGIN CERTIFICATE-----")) {
      console.error("‚ùå Certificate file does not contain proper PEM header");
      return false;
    }
    if (!certPem.includes("-----END CERTIFICATE-----")) {
      console.error("‚ùå Certificate file does not contain proper PEM footer");
      return false;
    }
    console.log("‚úÖ Certificate PEM format is valid");

    // Validate private key format
    console.log("üîç Validating private key format...");
    if (
      !keyPem.includes("-----BEGIN PRIVATE KEY-----") &&
      !keyPem.includes("-----BEGIN RSA PRIVATE KEY-----")
    ) {
      console.error("‚ùå Private key file does not contain proper PEM header");
      return false;
    }
    console.log("‚úÖ Private key PEM format is valid");

    // Parse certificate with forge
    console.log("üîç Parsing certificate with node-forge...");
    const cert = forge.pki.certificateFromPem(certPem);
    console.log("‚úÖ Certificate parsed successfully");
    console.log(
      `   Subject: ${cert.subject.getField("CN")?.value || "Unknown"}`,
    );
    console.log(`   Issuer: ${cert.issuer.getField("CN")?.value || "Unknown"}`);
    console.log(`   Valid from: ${cert.validity.notBefore}`);
    console.log(`   Valid until: ${cert.validity.notAfter}`);

    // Check if certificate is still valid
    const now = new Date();
    if (now < cert.validity.notBefore) {
      console.warn("‚ö†Ô∏è  Certificate is not yet valid");
    } else if (now > cert.validity.notAfter) {
      console.error("‚ùå Certificate has expired");
      return false;
    } else {
      console.log("‚úÖ Certificate is currently valid");
    }

    // Parse private key with forge
    console.log("\nüîç Parsing private key with node-forge...");
    const privateKey = forge.pki.privateKeyFromPem(keyPem);
    console.log("‚úÖ Private key parsed successfully");
    console.log(`   Key type: RSA`);
    console.log(`   Key size: ${privateKey.n.bitLength()} bits`);

    // Test key-certificate compatibility
    console.log("\nüîç Testing key-certificate compatibility...");
    const publicKeyFromCert = cert.publicKey;
    const publicKeyFromPrivate = forge.pki.rsa.setPublicKey(
      privateKey.n,
      privateKey.e,
    );

    if (
      publicKeyFromCert.n.equals(publicKeyFromPrivate.n) &&
      publicKeyFromCert.e.equals(publicKeyFromPrivate.e)
    ) {
      console.log("‚úÖ Certificate and private key match perfectly");
    } else {
      console.error("‚ùå Certificate and private key do not match");
      return false;
    }

    console.log("\nüéâ All certificate validations passed!");
    return true;
  } catch (error) {
    console.error(`‚ùå Error validating certificates: ${error.message}`);
    return false;
  }
}

// Run validation
validateCertificates();
